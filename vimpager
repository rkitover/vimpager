#!/bin/sh

# Script for using ViM as a PAGER.
# Based on Bram's less.sh.
# git://github.com/rkitover/vimpager.git

# Just pass through if not on a tty
if [ ! -t 1 ]; then
	exec cat "${@}"
fi

. "`dirname \"$0\"`/inc/prologue.sh"

version="$(cd "${0%/*}"; git describe) (git)"

case $(uname -s) in
	Linux) linux=1 ;;
	SunOS) solaris=1 ;;
        Darwin) osx=1; bsd=1 ;;
	CYGWIN*) cygwin=1; win32=1 ;;
	MINGW*) msys=1; win32=1 ;;
	MSYS*) msys=1; win32=1 ;;
	OpenBSD) openbsd=1; bsd=1 ;;
	FreeBSD) freebsd=1; bsd=1 ;;
	NetBSD) netbsd=1; bsd=1 ;;
	*) bsd=1 ;;
esac

main() {
	# if no args and no stdin, display usage
	if [ "${#}" -eq 0 -a -t 0 ]; then
		usage
		quit 0
	fi

	# check for -h and -v before main option parsing, this is much faster
	# set xtrace as early as possible, if requested
	for arg in "${@}"; do
		case "${arg}" in
			'-h'|'--help'|'-help'|'--usage'|'-usage')
				usage
				quit 0
				;;
			'-v'|'--version'|'-version')
				echo "vimpager $version"
				quit 0
				;;
			'-x')
				set -x
				;;
		esac
	done

	mkdir_options="-m 700"

	if [ -n "${msys}" -o -n "${cygwin}" ]; then
		# Use the real TEMP directory on windows in case we are
		# using a native vim/gvim...
		#
		# NOTE: sometimes TEMP=/tmp, this code handles that case as well

		tmp="${TEMP}"

		if command -v cygpath >/dev/null; then
			tmp="$(cygpath -w "${tmp}")"
		fi

		tmp="$(printf "%s\n" "${tmp}" | tr '\\' /)"

		# chmod doesn't work here, even in /tmp sometimes
		mkdir_options=""
	else
		# ... and /tmp otherwise
		tmp="/tmp"
	fi

	# Create a safe directory in which we place all other tempfiles.
	tmp="${tmp}/vimpager_${$}"
	if ! mkdir ${mkdir_options} "${tmp}"; then
	    echo "ERROR: Could not create temporary directory ${tmp}" >&2
	    quit 1
	fi
	trap "cd '${tmp}'/..; rm -rf '${tmp}' gvim.exe.stackdump" HUP INT QUIT ILL TRAP KILL BUS TERM

	# Detect terminal size
	if command -v tput >/dev/null; then
	        # this is the only way it works on some versions of Cygwin

		# 2>/dev/null makes tput not work, so don't do that
		# we are just going to hope that tput errors don't happen
		tput cols  > "${tmp}/cols"
		tput lines > "${tmp}/lines"

		cols=$(cat "${tmp}/cols")
		lines=$(cat "${tmp}/lines")

		rm -f "${tmp}/cols" "${tmp}/lines"
	fi

	# msys has no tput, this doesn't work on Cygwin by the way
	if [ -z "${cols}" ] && command -v bash >/dev/null; then
		cols=$(bash -i -c 'echo ${COLUMNS}')
		lines=$(bash -i -c 'echo ${LINES}')
	fi

	# If we are unable to detect lines/columns, maximize
	# the window.
	if [ -z "${cols}" ]; then
		cols=999
		lines=999
		no_pass_thru=1 # force loading vimpager
	fi

	# determine if this script is stripped/installed or not
	config
	if [ "${stripped}" -eq 0 ]; then
		runtime="${tmp}/runtime"
	elif [ "${configured}" -eq 0 ]; then
		runtime="${0%/*}"
	else
		runtime="${PREFIX}/share/vimpager"
	fi

	# determine location of rc file
	vim_dir="$(read_vim_var '$VIM')"

	user_vimrc="$(read_vim_var '$MYVIMRC')"

	user_vimrc_dir="${user_vimrc%/*}"

	# first check for a user ~/.vimpagerrc
	if [ -n "${VIMPAGER_RC}" ]; then
		vimrc="${VIMPAGER_RC}"
	# check for vimpagerrc in same dir as vimrc in case it is set in VIMINIT
	elif [ -r "${user_vimrc_dir}/.vimpagerrc" ]; then
		vimrc="${user_vimrc_dir}/.vimpagerrc"
	elif [ -r "${user_vimrc_dir}/_vimpagerrc" ]; then
		vimrc="${user_vimrc_dir}/_vimpagerrc"
	elif [ -r "${user_vimrc_dir}/vimpagerrc" ]; then
		vimrc="${user_vimrc_dir}/vimpagerrc"
	# check standard paths, according to :h initialization
	elif [ -r ~/.vimpagerrc ]; then
		vimrc=~/.vimpagerrc
	elif [ -r ~/.vim/vimpagerrc ]; then
		vimrc=~/.vim/vimpagerrc
	elif [ -r ~/_vimpagerrc ]; then
		vimrc=~/_vimpagerrc
	elif [ -r ~/vimfiles/vimpagerrc ]; then
		vimrc=~/vimfiles/vimpagerrc
	elif [ -r "${vim_dir}/_vimpagerrc" ]; then
		vimrc="${vim_dir}/_vimpagerrc"
	fi

	# use user's ~/.vimrc
	[ -z "${vimrc}" ] && vimrc="${user_vimrc}"

	# if no user vimrc, then check for a global /etc/vimpagerrc and fall back to NORC
	if [ -z "${vimrc}" ]; then
		if [ -f /usr/local/etc/vimpagerrc ]; then
			vimrc=/usr/local/etc/vimpagerrc
		elif [ -f /etc/vimpagerrc ]; then
			vimrc=/etc/vimpagerrc
		else
			vimrc=NORC
		fi
	fi

	# read settings
	vim -N -u "${vimrc}" -E -n -R -i NONE --cmd 'let g:vimpager = { "enabled": 1 }' -c '
		if !exists("g:vimpager.gvim")
			if !exists("g:vimpager_use_gvim")
				let g:vimpager.gvim = 0
			else
				let g:vimpager.gvim = g:vimpager_use_gvim
			endif
		endif

		if !exists("g:vimpager.X11")
			if !exists("g:vimpager_disable_x11")
				let g:vimpager.X11 = 1
			else
				let g:vimpager.X11 = !g:vimpager_disable_x11
			endif
		endif

		if !exists("g:vimpager.passthrough")
			if !exists("g:vimpager_passthrough")
				let g:vimpager.passthrough = 1
			else
				let g:vimpager.passthrough = g:vimpager_passthrough
			endif
		endif

		let g:use_ansiesc = 0

		if has("conceal") && (!exists("g:vimpager.ansiesc") || g:vimpager.ansiesc == 1) && (!exists("g:vimpager_disable_ansiesc") || g:vimpager_disable_ansiesc == 0)
			let g:use_ansiesc = 1
		endif

		call writefile([ g:vimpager.gvim, g:vimpager.X11, g:vimpager.passthrough, g:use_ansiesc ], "'${tmp}'/vimpager_opts")
		quit
	' </dev/null

	[ "$(line_n 1 "${tmp}/vimpager_opts")" -eq 1 ] && use_gvim=1

	[ "$(line_n 2 "${tmp}/vimpager_opts")" -eq 0 ] && disable_x11=1

	[ "$(line_n 3 "${tmp}/vimpager_opts")" -eq 0 ] && no_pass_thru=1

	[ "$(line_n 4 "${tmp}/vimpager_opts")" -ne 0 ] && ansiesc_available=1

	rm -f "${tmp}/vimpager_opts"

	if [ -n "${msys}" -o -n "${cygwin}" ]; then
		# msys/cygwin may be using a native vim, and if we're not in a real
		# console the native vim will not work, so we have to use gvim.

		if [ "x${TERM}" != "xdumb" -a "x${TERM}" != "xcygwin" -a "x${TERM}" != "x" ]; then
			if command -v vim >/dev/null | grep_q '^/(cygdrive/)?[a-z]/'; then
				use_gvim=1
			fi
		fi
	fi

	if [ -n "${use_gvim}" ]; then
		# determine if this is an ssh session and/or $DISPLAY is set
		if [ -n "${osx}" ]; then
			if [ -z "${SSH_CONNECTION}" ] && command -v mvim >/dev/null; then
				vim_cmd="mvim"
				gui=1
			else
				vim_cmd="vim"
			fi
		elif [ -n "${cygwin}" ]; then
			if command -v gvim >/dev/null; then
				if [ -n "${SSH_CONNECTION}" ]; then
					vim_cmd="vim"
				# The Cygwin gvim uses X
				elif win32_native gvim; then
					if [ -z "${DISPLAY}" ]; then
						vim_cmd="vim"
					else
						vim_cmd='gvim'
						gui=1
					fi
				else
					vim_cmd='gvim'
					gui=1
				fi
			else
				vim_cmd="vim"
			fi
		elif [ -n "${msys}" ]; then
			if [ -z "${SSH_CONNECTION}" ] && command -v gvim >/dev/null; then
				vim_cmd='gvim'
				gui=1
			else
				vim_cmd="vim"
			fi
		elif [ -z "${DISPLAY}" ]; then
			vim_cmd='vim'
		else
			if command -v gvim >/dev/null; then
				vim_cmd='gvim'
				gui=1
			else
				vim_cmd="vim"
			fi
		fi
	else
		vim_cmd='vim'
	fi

	rm -f gvim.exe.stackdump # for cygwin gvim, which can be part of vim

	if [ ! -n "${gui}" -a -n "${disable_x11}" ]; then
		vim_cmd="${vim_cmd} -X"
	fi

	ptree="$(do_ptree)"

	# Check if called from man, perldoc or pydoc
	if echo "${ptree}" | grep_q '([ \t]+|/)(man|[Pp]y(thon|doc)[0-9.]*|[Rr](uby|i)[0-9.]*)([ \t]|$)'; then
		is_man=1
		is_doc=1
		force_strip_ansi=1
	elif echo "${ptree}" | grep_q '([ \t]+|/)perl(doc)?([0-9.]*)?([ \t]|$)'; then
		is_perldoc=1
		is_doc=1
		force_strip_ansi=1
	fi

	extra_cmd="let g:vimpager.ptree=[$(echo "${ptree}" | awk '{ print "\"" $2 "\"" }' | tr '\n' ',')] | call remove(g:vimpager.ptree, -1) | let g:vimpager_ptree = g:vimpager.ptree"

	# Check for certain parameters to pass on to vim (or conceivably do something else)
	# Couldn't use getopt or getopts as neither supports options prepended with +
	while [ "${#}" -gt 0 ] ; do
	        case "${1}" in
	                '+G'|'+')
				vim_cmd="${vim_cmd} +";
				shift
				;;
			'-N'|'--LINE-NUMBERS')
				line_numbers=1
				shift
				;;
			'-c')
				shift
				if [ -z "${extra_c}" ]; then
					extra_c="${1}"
				else
					extra_c="${extra_c} | ${1}"
				fi
				shift
				;;
			'--cmd')
				shift
				if [ -z "${extra_cmd}" ]; then
					extra_cmd="${1}"
				else
					extra_cmd="${extra_cmd} | ${1}"
				fi
				shift
				;;
			'-u')
				shift
				vimrc="${1}"
				shift
				;;
			'-s') # Ubuntu man passes this option to /usr/bin/pager
				shift
				squeeze_blank_lines=1
				;;
			'--')
				shift
				break
				;;
			'-x')
				# xtrace should already be set by the first option parsing
				shift
				;;
			-*)
				echo "${0}: bad option '${1}', see --help for usage." >&2
				quit 1
				;;
			*)
				break
				;;
	         esac
	done

	# if no args, assume stdin
	if [ "${#}" -eq 0 ]; then
		set -- -
	# turn off passthrough and man/perldoc support for > 1 arg
	elif [ "${#}" -gt 1 ]; then
		is_man=''
		is_perldoc=''
		is_doc=''
		force_strip_ansi=''
	fi

	file_idx=1

	for file in "${@}"; do
		if [ "${file}" = - ]; then
			filename=stdin
		else
			if [ ! -r "${file}" ]; then
				echo "${0}: cannot read file '${file}'" >&2
				quit 1
			fi

			filename="${file}"
		fi

		set_key orig_file_names "${file_idx}" "${filename}"

		# $file still holds the orginal file name.  $filename will be
		# the encoded version of $file.  $tempfile is the path under
		# $tmp if the file is to be opend from there instead of the
		# original location.  If $tempfile is empty the file is to be
		# opened as $file.
		filename="$(encode_filename "${filename}")"
		tempfile=

		case "$(echo "${file}" | tr 'A-Z' 'a-z')" in
			*.gz)
				filename=${filename%.??}
				tempfile="${tmp}/${filename}"
				gunzip -c -- "${file}" > "${tempfile}"

				;;
			*.bz2)
				filename=${filename%.??2}
				tempfile="${tmp}/${filename}"
				bunzip2 -c -- "${file}" > "${tempfile}"
				;;
			*.xz)
				filename=${filename%.??}
				tempfile="${tmp}/${filename}"
				xzcat -c -- "${file}" > "${tempfile}"
				;;
			*.z)
				filename=${filename%.?}
				tempfile="${tmp}/${filename}"
				uncompress -c -- "${file}" > "${tempfile}"
				;;
			*)
				if [ "${file}" = "-" ]; then
					tempfile="${tmp}/${filename}"
					cat -- "${file}" > "${tempfile}"
				fi
				;;
		esac

		# check for ANSI codes and strip if not using ansiesc
		if head_n 100 "${tempfile:-"${file}"}" | grep_q "${ANSI_RE}"; then
			if [ -z "${ansiesc_available}" -o -n "${force_strip_ansi}" ]; then
				ansi_filter "${tempfile:-"${file}"}" > "${tmp}/${filename}.work"
				tempfile="${tmp}/${filename}"
				mv -f -- "${tempfile}.work" "${tempfile}"
			else
				use_ansiesc=1
				echo 'call vimpager_utils#DoAnsiEsc()' >> "${tmp}/${file_idx}.vim"
				set_key ansi_files "${file_idx}" yes
			fi
		fi

		# squeeze blank lines if option was specified, Ubuntu man with /usr/bin/pager does this
		if [ "${squeeze_blank_lines}" = "1" ]; then
				sed -e '/^[ 	]*$/{
					N
					/^[ 	]*\n[ 	]*$/D
				}' -- < "${tempfile:-"${file}"}" > "${tmp}/${filename}.work"
				tempfile="${tmp}/${filename}"
				mv -f -- "${tempfile}.work" "${tempfile}"
		fi

		# dumb man detection when the pstree heuristic fails
		if [ -z "${is_doc}" ] && head_n 12 "${tempfile:-"${file}"}" | grep_q '^NAME$'; then
			is_man=1
		fi

		# if it's a man page, remove starting blank lines, or the C syntax highlighting fails
		# and write out ft command for vim
		if [ -n "${is_doc}" ]; then
			ansi_filter "${tempfile:-"${file}"}" | overstrike_filter | awk '
				BEGIN { skipblank=1 }
				/^[ 	]*$/ { if (!skipblank) print }
				/[^ 	]/ { skipblank=0; print }
			' > "${tmp}/${filename}.work"
			tempfile="${tmp}/${filename}"
			mv -f -- "${tempfile}.work" "${tempfile}"

			if [ -n "${is_man}" ]; then
				echo 'set ft=man' >> "${tmp}/${file_idx}.vim"
			elif [ -n "${is_perldoc}" ]; then
				echo 'set ft=perldoc' >> "${tmp}/${file_idx}.vim"
			fi
		fi

		# if file is zero length, or one blank line (cygwin), and is only arg, exit
		if [ \( ! -s "${tempfile:-"${file}"}" \) \
			-o \( \( "$(cat "${tempfile:-"${file}"}")" = "" \) \
			-a \( "$(wc -l < "${tempfile:-"${file}"}")" -eq 1 \) \) ]; then

			if [ "${#}" -eq 1 ]; then
				quit 0
			fi
		fi

		# On cygwin it might be the win32 gvim, but windows paths work for cygwin
		# vim just fine as well.
		if [ -n "${cygwin}" ]; then
			filename=$(cygpath -w "${filename}" | tr '\\' /)
			tempfile=${tempfile:+"${tmp}/${filename}"}
		fi

		set_key files "${file_idx}" "${tempfile:-"${file}"}"

		file_idx="$((${file_idx} + 1))"
	done

	file_count="${#}"

	set --
	i=1
	while [ "${i}" -le "${file_count}" ]; do
		set -- "${@}" "$(get_key files "${i}")"
		i=$((${i} + 1))
	done

	if [ "${no_pass_thru:-0}" -ne 1 ] && fits_on_screen "${@}"; then
		cat_files=1
	fi

	page_files "$@"

	quit "${?}"
}

quit() {
	rm -f gvim.exe.stackdump # for a cygwin bug
	cd "${tmp}/.."
	rm -rf "${tmp}"
	exit "$@"
}

usage() {
	cat <<'EOF'
Usage: [32mvimpager [1;34m[[1;35mOPTION[1;34m][0m... [1;34m[[1;35mFILE [1;37m| [1;35m-[1;34m][0m...
Display [1;35mFILE[0m(s) in vim with a pager emulating less.

With no [1;35mFILE[0m, or when [1;35mFILE[0m is [1;35m-[0m, read standard input.

  [1;37m-h, --help, --usage[0m		Show this help screen and exit.
  [1;37m-v, --version[0m			Show version information and exit.
  [1;37m+G, +[0m				Go to the end of the file.
  [1;37m-N, --LINE-NUMBERS[0m		Show line numbers.
  [1;37m-s[0m				Squeeze multiple blank lines into one.
  [1;37m--cmd [1;35mCOMMAND[0m			Run vim [1;35mCOMMAND[0m before initialization.
  [1;37m-c [1;35mCOMMAND[0m			Run vim [1;35mCOMMAND[0m after initialization.
  [1;37m-u [1;35mFILE[0m			Use [1;35mFILE[0m as the vimrc.

Examples:
  [32mvimpager [1;35mprogram.py[0m		# view [1;35mprogram.py[0m in the pager
  PAGER=vimpager [32mman[0m 3 [1;35msprintf[0m	# view man page for [1;35msprintf[0m(3)

Project homepage and documentation: <[1;34mhttp://github.com/rkitover/vimpager[0m>
or available locally via: [32mman [1;35mvimpager[0m
Press '[1;35m,h[0m' for a summary of keystrokes in the program.
EOF
}

awk() {
	if [ -z "${_awk}" ]; then
		if command -v gawk >/dev/null; then
		    _awk=gawk
		elif command -v nawk >/dev/null; then
		    _awk=nawk
		elif command -v mawk >/dev/null; then
		    _awk=mawk
		elif [ -x /usr/xpg4/bin/awk ]; then
		    _awk=/usr/xpg4/bin/awk
		elif command -v awk >/dev/null; then
		    _awk=awk
		else
		    echo "ERROR: No awk found!" >&2
		    quit 1
		fi
	fi

	command "${_awk}" "$@"
}

sed() {
	if [ -z "${_sed}" ]; then
		if command -v gsed >/dev/null; then
			_sed=gsed
		elif [ -x /usr/xpg4/bin/sed ]; then
			_sed=/usr/xpg4/bin/sed
		elif command -v sed >/dev/null; then
			_sed=sed
		else
			echo "ERROR: No sed found!" >&2
			quit 1
		fi
	fi

	command "${_sed}" "$@"
}

# grep -q is often not available
grep_q() {
	_pat="$(echo "$1" | sed -e 's!/!\\/!g')"
	shift
	awk '
		BEGIN { exit_val = 1 }
		/'"$_pat"'/ { exit_val = 0; exit(exit_val) }
		END { exit(exit_val) }
	' "$@"
}

head_n() {
	_lines=$1
	shift

	if [ -z "$_head_syntax" ]; then
		_head1_test="$(echo xx | head -n 1 2>/dev/null)"
		if [ "$_head1_test" = "xx" ]; then
			_head_syntax=new
		else
			_head_syntax=old
		fi
	fi

	if [ "$_head_syntax" = "new" ]; then
		head -n $_lines -- "$@"
	else
		head -$_lines -- "$@"
	fi
}

tail_n() {
	_lines=$1
	shift

	if [ -z "$_tail_syntax" ]; then
		_tail1_test="$(echo xx | tail -n 1 2>/dev/null)"
		if [ "$_tail1_test" = "xx" ]; then
			_tail_syntax=new
		else
			_tail_syntax=old

			if ! tail -1 -- "$0" > /dev/null 2>&1; then
				_tail_no_double_dash=1
			fi
		fi
	fi

	if [ "$_tail_syntax" = "new" ]; then
		tail -n "$_lines" -- "$@"
	elif [ -z "$_tail_no_double_dash" ]; then
		tail -"$_lines" -- "$@"
	else
		tail -"$_lines" "$@"
	fi
}

line_n() {
	_line="${1}"
	shift

	head_n "${_line}" "${@}" | tail_n 1 | tr -d '\n'
}

read_vim_var() {
	vim -N -E -n -R -i NONE -c 'call writefile([ '"$1"' ], "'${tmp}'/vimpager_vimvar_'${$}'") | q' </dev/tty >/dev/null 2>&1
	_var="$(head -n 1 "${tmp}/vimpager_vimvar_${$}")"

	rm -f "${tmp}/vimpager_vimvar_${$}"

	echo "${_var}"
	unset _var

	return 0
}

extract_bundled_scripts() {
	mkdir "${runtime}"

	(
		cd "${runtime}"

		mkdir macros autoload plugin syntax bin

		# we extract all files in case the user uses :Page or :Page!
		autoload_vimpager_vim
		autoload_vimpager_utils_vim
		plugin_vimpager_vim
		less_vim

		perldoc_vim

		ansi_esc_vim
		ansi_esc_plugin_vim
		cecutil_plugin_vim

		if [ -n "${cat_files}" ]; then
			vimcat_script
			chmod +x ./bin/vimcat
		fi
	)
}

# Adapted from: https://gist.github.com/moyashi/4063894
# We are escaping only slashes, spaces, and chars special to vim (see :h expand).
encode_filename() {
	echo "${@}" | awk '
BEGIN {
    for (i = 0; i <= 255; i++) {
	ord[sprintf("%c", i)] = i
    }
}

{
    len = length($0)
    res = ""
    for (i = 1; i <= len; i++) {
	c = substr($0, i, 1);
	if (c ~ /[\/#%<>|\\ 	]/)
	    res = res "%" sprintf("%02X", ord[c])
	else
	    res = res c
    }
    print res
}
'
}

# emulate arrays
set_key() {
	eval "${1}_${2}=\"${3}\""
}

get_key() {
	eval "echo \"\${${1}_${2}}\""
}

# this actually runs vim or gvim, or vimcat, or just cats the file
page_files() {
	if [ "${stripped}" -eq 0 ]; then
		extract_bundled_scripts
		vimcat="${runtime}/bin/vimcat"
	else
		if command -v vimcat > /dev/null; then
			vimcat="$(command -v vimcat)"
		elif [ "${configured}" -eq 0 ]; then
			vimcat="${0%/*}/vimcat"
		else
			vimcat="${PREFIX}/bin/vimcat"
		fi
	fi

	if [ -n "${cat_files}" ]; then
		i=1
		for cur_file in "${@}"; do
			orig_file="$(get_key orig_file_names "${i}")"

			if [ "${#}" -gt 1 ]; then
				if [ "${i}" -gt 1 ]; then
					printf '\n'
				fi
				printf '==> %s <==\n\n' "${orig_file}"
			fi

			if [ -n "$(get_key ansi_files "${i}")" ]; then
				cat "${cur_file}"
				_exit_status="${?}"
			else
				"${POSIX_SHELL}" "${vimcat}" \
					-u "${vimrc}" \
					--cmd "set rtp^=${runtime} | let vimpager={ 'enabled': 1 }" \
					--cmd "${extra_cmd:-echo}" \
					-c 'silent! source %.vim' \
					-c "${extra_c:-echo}"  \
					"${cur_file}" </dev/tty
				_exit_status="${?}"
			fi
			i="$((${i} + 1))"
		done
		return "${_exit_status:-0}"
	fi

	init_opts="'columns': ${cols}, 'tmp_dir': '${tmp}', 'line_numbers': ${line_numbers:-0}, 'is_doc': ${is_doc:-0}"

	VIMPAGER_TMP="${tmp}" \
	${vim_cmd} -N -i NONE \
		-u "${vimrc}" \
		--cmd "set rtp^=${runtime}" \
		--cmd "call vimpager#Init({ ${init_opts} })" \
		--cmd "${extra_cmd:-echo}" \
		-c "${extra_c:-echo}"  \
		"${@}" </dev/tty

	_vim_exit_status="${?}"

	if [ -n "${gui}" ]; then
		( (
			while [ ! -e "${tmp}/gvim_done" ]; do
				sleep 1
			done
			quit 0
		) & ) & # double fork to ignore HUP etc.

		exit "${_vim_exit_status}" # must NOT delete "${tmp}"
	fi

	return "${_vim_exit_status}"
}

awk_pstree() {
	awk -v mypid=${1} '{
	        cmd[$1]=substr($0, index($0, $3))
		ppid[$1]=$2
	}
	END {
		while (mypid != 1 && cmd[mypid]) {
			ptree=mypid " " cmd[mypid] "\n" ptree
			mypid=ppid[mypid]
		}
		print ptree
	}'
}

cygwin_ps() {
	ps | sed 's/^[^0-9]*//; /^$/d' | awk '{ print $1 " " $2 " " substr($0, index($0, $8)) }'
}

do_ptree() {
	if [ -n "${solaris}" ]; then
		# Tested on Solaris 8 and 10
		ptree "${$}"
	elif [ -n "${win32}" ]; then
		cygwin_ps | awk_pstree "${$}"
	else
		ps aw -o pid= -o ppid= -o command= | awk_pstree "${$}"
	fi 2>/dev/null
}

win32_native() {
	if [ "x$(get_key _win32_native "${1}")" = "x1" ]; then
		return 0
	else
		if [ -n "${msys}" -o -n "${cygwin}" ]; then
			if command -v "${1}" > /dev/null | grep_q '^/(cygdrive/)?[a-z]/'; then
				set_key _win32_native "${1}" 1
				return 0
			else
				set_key _win32_native "${1}" 0
				return 1
			fi
		else
			set_key _win32_native "${1}" 0
			return 1
		fi
	fi
	return 1
}

# this is compatible with osed
ANSI_RE='\[[;?]*[0-9.;]*[A-Za-z]'

ansi_filter() {
	sed -e 's/'"${ANSI_RE}"'//g' "${@}"
}

# Even /bin/sed on Solaris handles UTF-8 characters correctly, so we can safely
# use sed for this.
overstrike_filter() {
	sed 's/.//g' "${@}"
}

fits_on_screen() {
	[ $# -eq 0 ] && set -- -

	# First remove overstrikes and ANSI codes with sed
	ansi_filter "${@}" | overstrike_filter | \
	awk '
	{
	    if (NR == 1) {
		lines = total_lines - 2 - (num_files - 1) * file_sep_lines

		if (num_files - 1)
		    lines -= first_file_sep_lines

		total_cols += 0 # coerce to number
	    }

	    col = 0

	    for (pos = 1; pos <= length($0); pos++) {
		c = substr($0, pos, 1)

		# handle tabs
		if (c == "\t")
		    col += 8 - (col % 8)
		else
		    col++

		if (col > total_cols) {
		    if (!--lines) exit(1)
		    col = 1
		}
	    }

	    if (!--lines) exit(1)
	}
	' num_files="${#}" total_lines="${lines}" total_cols="${cols}" file_sep_lines=3 first_file_sep_lines=2 -
}

config() {
	stripped=1
	configured=0
	PREFIX="${0%/*}"
}

# INCLUDE BUNDLED SCRIPTS HERE
# END OF BUNDLED SCRIPTS

main "$@"

# Copyright (c) 2016, Rafael Kitover <rkitover@gmail.com> and
# Contributors (below.)
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# * Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
# * Redistributions in binary form must reproduce the above copyright
# notice, this list of conditions and the following disclaimer in the
# documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# CONTRIBUTORS:
#
# Rafael Kitover
# Antonio Ospite
# Jean-Marie Gaillourdet
# Perry Hargrave
# Koen Smits
# Ivan S. Freitas <ivansichfreitas@gmail.com>
# Wout Mertens (Solaris compatibility, less processes)
# Jacobo de Vera (add -X option for faster startup)
# Damien Pollet <damien.pollet@gmail.com>
# Peter Fern <github@obfusc8.org>
# Wei Dai <x@wei23.net>
# Iftekharul Haque <iftekharul.haque@gmail.com>
# Anselm Strauss <amsibamsi@gmail.com>
# Anisse Astier <anisse@astier.eu>
# Simon Olofsson <simon@olofsson.de>
# lickel: Adam Lickel <adam@lickel.com>
# eworm-de: Christian Hesse <mail@eworm.de>
# krijesta: Chris Chambers <krijesta@google.com>
# vincer: vince rosso <vince@locationlabs.com>
# justinkb: Paul Mulders <justinkb@gmail.com>
# nonakap: NONAKA Kimihiro <nonakap@gmail.com>
# dfechner: Dustin Fechner <fechnedu@gmail.com>
# lucc: Lucas Hoffmann <l-m-h@web.de>
# aroig: Abdo Roig-Maranges <abdo.roig@gmail.com>
# mortonfox: Morton Fox <github@mortonfox.otherinbox.com>
# mapeiqi88: <mapeiqi88@gmail.com>
# snordhausen: Stefan Nordhausen <stefan.nordhausen@axiros.com>
# renatosilva: Renato Silva <br.renatosilva@gmail.com>
# dragon788: <dragon788@users.noreply.github.com>
# ahamad-s: donnie' <ahamad-s@users.noreply.github.com>
# SethMilliken: Seth Milliken <seth.milliken@urbanairship.com>
# trapd00r: Magnus Woldrich <m@japh.se>
# ghedo: Alessandro Ghedini <alessandro@ghedini.me>
# guiniol: Guillaume Brogi <gui-gui@netcourrier.com>
# leandro-lucarella-sociomantic: Leandro Lucarella <leandro.lucarella@sociomantic.com>
# derekschrok: Derek Schrock <dereks@lifeofadishwasher.com>
# wilywampa: Jacob Niehus <jacob.niehus@gmail.com>

# vim: noet ts=8 sts=8 sw=8 tw=0:
